import * as config from '../src/config.js'
import type * as types from './types.js'
import { generateMessageResponseUsingOpenAI } from './answer-engines/openai.js'
import { BotError } from './bot-error.js'
import { stripAtMentions } from './utils.js'

const MAX_TWEET_LENGTH = 280

export async function generateMessageResponse(
  message: types.Message,
  ctx: types.Context
) {
  switch (ctx.answerEngine) {
    case 'openai':
      await generateMessageResponseUsingOpenAI(message, ctx)
      break

    case 'dexa':
      throw new Error('TODO: Dexa answer engine not yet implemented')

    default:
      throw new Error(`Unknown answer engine: ${ctx.answerEngine}`)
  }

  validateMessageResponse(message, ctx)

  // TODO: validate message.response
  if (config.disallowMentionsInBotReplies) {
    message.response = stripAtMentions(message.response!)
    validateMessageResponse(message, ctx)
  }

  // TODO: handle trucation with URLs properly
  if (message.response!.length >= MAX_TWEET_LENGTH) {
    message.response =
      message.response!.slice(0, MAX_TWEET_LENGTH - 3).trim() + '...'
  }
}

export function validateAnswerEngine(answerEngine: string) {
  switch (answerEngine) {
    case 'openai':
      if (!process.env.OPENAI_API_KEY) {
        throw new Error(
          'OPENAI_API_KEY is required for the "openai" answer engine'
        )
      }
      break

    case 'dexa':
      throw new Error('TODO: Dexa answer engine not yet implemented')

    default:
      throw new Error(`Unknown answer engine: ${answerEngine}`)
  }
}

function validateMessageResponse(message: types.Message, ctx: types.Context) {
  message.response = message.response?.trim()
  if (!message.response) {
    throw new BotError(
      `Empty response generated by answer engine ${ctx.answerEngine}`,
      {
        type: 'answer-engine:invalid-response',
        isFinal: true
      }
    )
  }
}
